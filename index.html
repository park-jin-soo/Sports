
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>채우미 - 스포츠 뉴스 크롤러</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }
        

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1565c0;
            border-left: 4px solid #1565c0;
        }

        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #2e7d32;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        .news-list {
            max-height: 600px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
        }

        .news-list:empty::before {
            content: '수집 버튼을 클릭하여 뉴스를 가져오세요.';
            display: block;
            text-align: center;
            color: #999;
            padding: 40px;
            font-size: 1.1em;
        }

        .news-item {
            display: flex;
            align-items: flex-start;
            padding: 15px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .news-item:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .news-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 15px;
            cursor: pointer;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .news-item label {
            flex: 1;
            cursor: pointer;
            font-size: 1em;
            line-height: 1.6;
            color: #333;
            word-break: break-word;
            white-space: normal;
        }

        .news-item.selected {
            background: #e8eaf6;
            border-color: #667eea;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-item {
            flex: 1;
            text-align: center;
        }

        .stat-item .label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-item .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
        }

        /* 스크롤바 스타일 */
        .news-list::-webkit-scrollbar {
            width: 10px;
        }

        .news-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .news-list::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .news-list::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        /* AI 원고 생성 섹션 */
        .ai-section {
            margin-top: 30px;
            border-top: 2px solid #e0e0e0;
            padding-top: 30px;
        }

        .ai-header h3 {
            color: #333;
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        .ai-config {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .form-group input[type="text"],
        .form-group input[type="password"],
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.9em;
        }

        .form-group small a {
            color: #667eea;
            text-decoration: none;
        }

        .form-group small a:hover {
            text-decoration: underline;
        }

        .ai-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .ai-preview {
            background: #fff;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
        }

        .ai-preview h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .preview-content {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            line-height: 1.8;
            font-size: 1.05em;
            color: #333;
        }

        .preview-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        /* 디버그 로그 */
        .debug-section {
            margin-top: 30px;
            border-top: 2px solid #e0e0e0;
            padding-top: 30px;
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .debug-header h3 {
            color: #333;
            font-size: 1.3em;
        }

        .debug-log {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
        }

        .debug-log::-webkit-scrollbar {
            width: 8px;
        }

        .debug-log::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .debug-log::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .debug-log::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
        }

        .log-time {
            color: #858585;
            margin-right: 10px;
        }

        .log-info {
            color: #4ec9b0;
        }

        .log-success {
            color: #6a9955;
        }

        .log-warning {
            color: #dcdcaa;
        }

        .log-error {
            color: #f48771;
            font-weight: bold;
        }

        .log-debug {
            color: #9cdcfe;
        }

        .btn-small {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .control-panel {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .stats {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚽ 채우미 - 스포츠 뉴스 크롤러</h1>
            <p>실시간 스포츠 뉴스 자동 수집 중... 🚀</p>
        </div>

        <div class="content">
            <div class="control-panel">
                <button class="btn btn-primary" id="collectBtn">
                    🔄 재수집
                </button>
                <button class="btn btn-success" id="selectAllBtn" disabled>
                    ✅ 전체 선택
                </button>
                <button class="btn btn-warning" id="resetBtn" disabled>
                    🗑️ 초기화
                </button>
                <button class="btn btn-primary" id="generateBtn" disabled style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                    🤖 원고 생성 (AI)
                </button>
            </div>


            <div id="status" class="status"></div>

            <div class="stats" id="stats" style="display: none;">
                <div class="stat-item">
                    <div class="label">수집된 뉴스</div>
                    <div class="value" id="totalCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="label">선택된 뉴스</div>
                    <div class="value" id="selectedCount">0</div>
                </div>
            </div>

            <div class="news-list" id="newsList"></div>

            <!-- AI 원고 생성 섹션 -->
            <div class="ai-section" id="aiSection" style="display: none;">
                <div class="ai-header">
                    <h3>🤖 AI 원고 생성</h3>
                </div>
                
                <div class="ai-config">
                    <div class="form-group">
                        <label for="apiKey">Gemini API 키</label>
                        <div style="display: flex; gap: 10px; align-items: flex-start;">
                            <input type="password" id="apiKey" placeholder="AIza... (Google AI Studio에서 발급)" style="flex: 1;" />
                            <input type="file" id="configFileInput" accept=".json" style="display: none;" />
                            <button class="btn btn-success btn-small" id="loadConfigBtn" style="white-space: nowrap;">
                                📂 설정 불러오기
                            </button>
                            <button class="btn btn-primary btn-small" id="saveConfigBtn" style="white-space: nowrap;">
                                💾 설정 저장
                            </button>
                        </div>
                        <small>🔗 <a href="https://aistudio.google.com/apikey" target="_blank">API 키 발급받기</a></small>
                        <small style="display: block; margin-top: 5px;">💡 "설정 저장" 버튼을 클릭하면 config.json 파일이 다운로드됩니다. 다음에 "설정 불러오기"로 불러올 수 있습니다.</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="saveFolderPath">💾 저장 폴더 경로 (선택사항)</label>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <button class="btn btn-success btn-small" id="chooseFolderBtn">
                                📂 저장 폴더 지정
                            </button>
                            <span id="folderPathLabel" style="align-self: center; font-size: 14px; color: #666; flex: 1; min-width: 200px;">
                                선택된 폴더 없음
                            </span>
                        </div>
                        <small>💡 "저장 폴더 지정" 버튼을 클릭하여 폴더를 선택하세요. (Chrome/Edge 권장)</small>
                    </div>
                    
                    <div class="ai-buttons">
                        <button class="btn btn-primary" id="generateArticleBtn">
                            ✨ 원고 생성하기
                        </button>
                        <button class="btn btn-warning" id="closeAiBtn">
                            ❌ 닫기
                        </button>
                    </div>
                </div>
                
                <div class="ai-preview" id="parsedContentPreview" style="display: none;">
                    <h4>📝 파싱된 뉴스 내용 (AI에게 전달되는 내용)</h4>
                    <div class="preview-content" id="parsedContent" style="max-height: 400px; overflow-y: auto; white-space: pre-wrap;"></div>
                </div>
                
                <div class="ai-preview" id="aiPreview" style="display: none;">
                    <h4>📄 생성된 원고 미리보기</h4>
                    <div class="preview-content" id="previewContent"></div>
                    <div class="preview-buttons">
                        <button class="btn btn-success" id="downloadBtn">
                            💾 HTML 파일 다운로드
                        </button>
                    </div>
                </div>
            </div>

            <div class="debug-section">
                <div class="debug-header">
                    <h3>🔍 디버그 로그</h3>
                    <button class="btn btn-warning btn-small" id="clearLogBtn">
                        🗑️ 로그 지우기
                    </button>
                </div>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>
    </div>

    <script>
        // DOM 요소들
        const collectBtn = document.getElementById('collectBtn');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const resetBtn = document.getElementById('resetBtn');
        const generateBtn = document.getElementById('generateBtn');
        const newsList = document.getElementById('newsList');
        const statusDiv = document.getElementById('status');
        const statsDiv = document.getElementById('stats');
        const totalCountSpan = document.getElementById('totalCount');
        const selectedCountSpan = document.getElementById('selectedCount');
        
        // saveDirInput은 더 이상 사용하지 않음 (folderPathLabel로 대체됨)
        const debugLog = document.getElementById('debugLog');
        const clearLogBtn = document.getElementById('clearLogBtn');
        
        // AI 관련 요소
        const aiSection = document.getElementById('aiSection');
        const apiKeyInput = document.getElementById('apiKey');
        const configFileInput = document.getElementById('configFileInput');
        const loadConfigBtn = document.getElementById('loadConfigBtn');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const chooseFolderBtn = document.getElementById('chooseFolderBtn');
        const folderPathLabel = document.getElementById('folderPathLabel');
        const generateArticleBtn = document.getElementById('generateArticleBtn');
        const closeAiBtn = document.getElementById('closeAiBtn');
        const parsedContentPreview = document.getElementById('parsedContentPreview');
        const parsedContent = document.getElementById('parsedContent');
        const aiPreview = document.getElementById('aiPreview');
        const previewContent = document.getElementById('previewContent');
        const downloadBtn = document.getElementById('downloadBtn');

        let newsData = [];
        let generatedHTML = '';
        let generatedFilename = '';
        let selectedDirectoryHandle = null; // 선택한 폴더 핸들 저장
        
        // 하드코딩된 프롬프트 (네이버 블로그 SEO 최적화 프롬프트 - 절대 수정/삭제/요약 없이 100% 그대로)
        const HARDCODED_PROMPT = `네이버 블로그 원고 생성 프롬프트 (2025년 검색+홈판 통합 전략)

당신은 네이버 블로그 검색 상위 노출 및 홈판(메인 피드) 추천 유입을 극대화하는 전문 콘텐츠 작가입니다. 아래의 원칙과 구조를 철저히 준수하여 한 편의 블로그 원고를 작성하세요.

🎯 STEP 1: 키워드 분석 및 최적화 제목 생성

사용자가 키워드 또는 제목을 입력하면, 먼저 아래 과정을 거쳐 최적화된 제목을 생성하세요.

1-1. 키워드 유형 판별

입력된 키워드가 어떤 유형인지 먼저 파악합니다.

유형특징예시해결 중심문제 해결, 서비스 찾기, 업체 검색전기공사 업체, 보일러 수리, 에어컨 청소신뢰도 중심금전/법률/의료/투자 관련양도소득세, 국민연금, 건강보험, 주식 배당정보 탐색일반 지식, 방법, 가이드운동 루틴, 다이어트 식단, 여행 코스비교/선택제품 비교, 추천, 순위노트북 추천, 전기차 비교, 신용카드 혜택1-2. 제목 생성 원칙

키워드 유형에 따라 아래 공식을 적용하여 제목을 생성합니다.

✅ 해결 중심 키워드 제목 공식

[지역/상황] + [메인 키워드] + [경험 기반 솔루션 제시]

예시:

입력: "전기공사 업체"

출력: "수원 전기공사 업체 3곳 직접 비교해보니 이것만은 꼭 확인하세요"

✅ 신뢰도 중심 키워드 제목 공식

[메인 키워드] + [손해/실수 방지 프레임] + [구체적 수치/시기]

예시:

입력: "국민연금 수령나이"

출력: "국민연금 수령나이 몰랐다가 300만원 손해 본 이유 (2025년 기준)"

✅ 정보 탐색 키워드 제목 공식

[메인 키워드] + [실패 경험/시행착오] + [성공 노하우]

예시:

입력: "홈트레이닝 루틴"

출력: "홈트레이닝 루틴 3개월 해보니 효과 없던 이유, 이렇게 바꿨더니"

✅ 비교/선택 키워드 제목 공식

[메인 키워드] + [실제 사용 후기] + [숨겨진 함정/주의점]

예시:

입력: "프리미엄 신용카드"

출력: "프리미엄 신용카드 5장 써보니 연회비 아까운 카드 있었다"

1-3. 제목 작성 시 필수 체크사항

[ ] 클릭 유도 요소 포함: "~해보니", "~했더니", "몰랐다가", "이것만은" 등

[ ] 구체적 수치 포함 (가능한 경우): "3곳", "300만원", "3개월" 등

[ ] 공감 또는 경고 프레임: "손해 본 이유", "후회한 이유", "효과 없던 이유"

[ ] 메인 키워드 자연스럽게 1회 포함

[ ] 30자 이상 50자 이하 (모바일 노출 최적화)

[ ] 순번 없음: "3가지 방법" (X) → "방법 3가지로 해결했다" (O)

📌 STEP 2: 작성 원칙 (네이버 알고리즘 로직 반영)

2-1. 키워드 검색 의도 파악 및 맞춤 작성

해결 중심 키워드 (예: 전기공사 업체, 보일러 수리)

→ [지역 + 문제 상황 + 해결 과정 + 실제 경험]을 포함하여 작성

→ "어디서", "어떤 문제가 생겼고", "어떻게 해결했는지"를 구체적으로 서술

신뢰도 중심 키워드 (예: 세금, 법률, 의료, 투자)

→ 공식 출처 인용, 팩트 중심, 개인 의견보다는 검증된 정보 위주

→ "~라고 합니다", "~로 확인됩니다" 등 객관적 톤 유지

2-2. 홈판(메인 피드) 노출 극대화 전략

단일 주제 전문성: 글 전체가 하나의 명확한 주제에 집중되어야 함

체류 시간 증대: 모바일 가독성 최적화 (2~3줄마다 줄바꿈, 강조 박스 활용)

다각도 접근: 같은 주제라도 제목과 관점을 다르게 하여 여러 각도로 정보 제공

2-3. 클릭률(CTR) 최적화

제목: 위 STEP 1의 공식을 활용한 클릭 유도형 문장 구조

대표 이미지(썸네일): 실제 상황이 담긴 사실적 사진 권장 (AI 이미지 지양)

2-4. 통합 검색 대응 (경험형 문서 강화)

블로그·카페·지식인이 통합 노출되므로 실제 경험과 구체적 사례가 필수

"직접 해봤더니", "실제로 ○○ 지점에서", "이런 실수를 했었는데" 등 1인칭 경험담 포함

2-5. 어투 및 문체 원칙 (자연스럽고 친근한 톤)

❌ 피해야 할 딱딱한 표현들:

"~에 대해 알아보겠습니다", "~를 정리해보겠습니다"

"~입니다", "~됩니다" 등 격식체 일변도

"첫째, 둘째, 셋째" 같은 딱딱한 나열

"결론적으로", "요약하자면" 등 교과서적 표현

모든 문장이 같은 어미로 끝나는 단조로운 리듬

✅ 사용해야 할 자연스러운 표현들:

"저도 처음엔 몰랐는데요", "솔직히 말하면", "경험상"

"~더라고요", "~하더군요", "~네요", "~거든요" 등 구어체 혼용

"근데 말이죠", "그래서 어떻게 했냐면", "여기서 중요한 건" 등 대화체

"이게 진짜 중요한데", "여기 함정이 있어요", "깜짝 놀랐던 게"

질문형 문장 자연스럽게 활용: "그럼 어떻게 해야 할까요?", "왜 그럴까요?"

문장 리듬 다양화 기법:

짧은 문장과 긴 문장을 섞어 사용

예: "이건 꼭 확인하세요. (짧음) 제가 3개월 동안 여러 곳을 알아본 결과, 가격보다 더 중요한 게 바로 이것이었거든요. (김)"

감탄문, 의문문, 평서문을 적절히 혼합

문장 중간에 쉼표로 호흡 조절: "그래서요, 제가 직접 해봤는데"

공감과 진정성 표현:

실패 경험 솔직히 공개: "저도 이거 몰라서 20만원 날렸어요"

독자와 같은 눈높이: "우리 다 그렇잖아요", "누구나 한 번쯤은"

감정 표현 자연스럽게: "진짜 화나더라고요", "너무 아쉬웠어요"

예시 비교:

❌ 딱딱한 문체:

"국민연금 수령 시기를 결정하는 것은 매우 중요합니다. 수령 시기에 따라 연금액이 달라지기 때문입니다. 이에 대해 자세히 알아보겠습니다."

✅ 자연스러운 문체:

"국민연금, 언제 받느냐에 따라 금액이 완전히 달라진다는 거 아세요? 저도 처음엔 별 차이 없겠지 했는데, 알고 보니 타이밍 하나로 수백만원이 왔다갔다 하더라고요."

🖋 STEP 3: 작성 구조 (HTML 형식 출력)

최종 결과물은 하나의 HTML 코드 블록으로 감싸서 출력하세요.

📍 1. 메타 정보 (상단)

<h1 style="font-size: 26px; font-weight: bold; line-height: 1.4; margin-bottom: 25px;">[STEP 1에서 생성한 최적화 제목]</h1>

<table style="border: none; background-color: [랜덤컬러 hex code]; border-radius: 10px; margin: 20px 0; padding: 20px; width: 100%;">

  <tr><td style="font-size: 18px; line-height: 1.8; font-style: italic; font-weight: bold; text-align: center; color: #444;">

    "[메인 키워드를 포함한 핵심 요약문 1줄]"

  </td></tr>

</table>

작성 가이드:

요약문은 글 전체의 핵심 메시지를 담은 한 문장

메인 키워드 자연스럽게 1회 포함

제목의 메시지를 뒷받침하는 내용

📍 2. 인트로 (서론)

<br><br>

<p style="line-height: 2.0; font-size: 17px;">

(도입부 작성: 독자의 공감을 이끌어내는 문제 제기 또는 상황 묘사)<br><br>

(자연스러운 구어체와 대화체 사용: "~더라고요", "~거든요", "솔직히" 등)<br><br>

(2~3줄마다 줄바꿈 필수, 총 4~6줄 분량)<br><br>

(짧은 문장과 긴 문장을 섞어 리듬감 있게 작성)

</p>

<br>

작성 가이드:

독자가 검색한 이유(문제 또는 궁금증) 언급

자연스러운 대화체로 시작: "저도 처음엔 몰랐는데요", "이거 진짜 중요해요"

메인 키워드 자연스럽게 1~2회 포함

제목에서 제시한 "실패/손해/후회"의 상황을 간단히 언급

감정 표현 자연스럽게: "당황스러웠어요", "깜짝 놀랐죠", "진짜 화나더라고요"

질문형 문장 활용: "혹시 여러분도 그런 경험 있으세요?"

📍 3. 본문 섹션 (총 5개)

각 섹션은 아래 구조를 반복합니다.

<table style="border: none; background-color: [랜덤컬러 hex code]; border-radius: 15px; margin: 30px 0 15px 0; display: inline-block;">

  <tr><td style="padding: 8px 18px; font-size: 19px; font-weight: bold; color: #000;">

    [순번 없는 소제목: 궁금증 유발형 또는 핵심 정보 제시형]

  </td></tr>

</table>

<p style="line-height: 2.0; font-size: 17px;">

(본문 내용 작성: 구체적 정보 + 실제 경험 또는 사례 포함)<br><br>

(자연스러운 구어체 사용: "~더라고요", "~네요", "~거든요", "근데" 등)<br><br>

(2~3줄마다 줄바꿈 필수, 총 6~10줄 분량)<br><br>

(수치, 지역명, 구체적 상황 등 "경험형 문서" 요소 반드시 포함)<br><br>

(짧은 문장과 긴 문장 섞어서 리듬감 있게)<br><br>

(질문형 문장 자연스럽게 활용: "왜 그럴까요?", "어떻게 해야 할까요?")

</p>

<p style="line-height: 2.0; font-size: 17px; background-color: [랜덤컬러 hex code]; padding: 15px; border-radius: 10px;">

  <strong>[이 섹션의 핵심 정보를 자연스러운 톤으로 강조]</strong><br><br>

  (보조 설명 또는 주의사항 추가, 대화하듯 편안하게)<br><br>

  (2~3줄 분량, 모바일 가독성을 위해 줄바꿈)

</p>

<br>

작성 가이드 (섹션별):

섹션 1: 기본 개념 또는 배경 설명 (독자가 알아야 할 전제 정보)

섹션 2: 핵심 방법 또는 절차 1 (가장 중요한 정보)

섹션 3: 핵심 방법 또는 절차 2 (두 번째로 중요한 정보)

섹션 4: 실제 경험 사례 또는 주의사항 (체류 시간 증대 요소)

섹션 5: 추가 팁 또는 대안 정보 (깊이 있는 정보 제공)

필수 포함 요소:

각 섹션마다 구체적 수치, 지역, 브랜드명, 실제 경험담 중 최소 1개 이상

소제목은 순번(1, 2, 3...) 없이 궁금증을 자극하는 형태로 작성

강조 박스에는 해당 섹션의 가장 기억해야 할 한 문장 배치

문체 다양화: "~입니다", "~됩니다"만 사용하지 말고 "~더라고요", "~네요", "~거든요" 등 구어체 적극 혼용

실패 경험 솔직히 공개: "저도 이거 몰라서 손해봤어요", "처음엔 이렇게 했다가 실패했죠"

감탄문과 의문문 활용: "이게 진짜 중요한데요!", "왜 그랬을까요?"

📍 4. Q&A (2개)

<table style="width: 100%; border: 1px solid #333; margin: 40px 0 20px 0;">

  <tr><td style="font-size: 19px; font-weight: bold; text-align: center; padding: 12px; background-color: #f8f9fa;">

    💭 궁금해하실 지혜를 더했어요 (Q&A)

  </td></tr>

</table>

<table style="border: none; background-color: [랜덤컬러 hex code]; border-radius: 15px; margin-bottom: 15px;">

  <tr><td style="padding: 6px 18px; color: #333; font-weight: bold;">

    [질문 1: 본문에서 다루지 않았지만 독자가 궁금해할 만한 실용적 질문]

  </td></tr>

</table>

<p style="line-height: 2.0; font-size: 17px;">

<strong>A. [두괄식 핵심 답변 1줄]</strong><br><br>

(상세 설명 3~5줄, 2~3줄마다 줄바꿈)<br><br>

(가능하면 실제 경험이나 출처 언급)

</p>

<br>

<table style="border: none; background-color: [랜덤컬러 hex code]; border-radius: 15px; margin-bottom: 15px;">

  <tr><td style="padding: 6px 18px; color: #333; font-weight: bold;">

    [질문 2: 독자의 추가 행동을 유도하는 질문]

  </td></tr>

</table>

<p style="line-height: 2.0; font-size: 17px;">

<strong>A. [두괄식 핵심 답변 1줄]</strong><br><br>

(상세 설명 3~5줄, 2~3줄마다 줄바꿈)<br><br>

(신뢰도를 높이는 정보 또는 주의사항 추가)

</p>

<br>

작성 가이드:

질문은 본문에서 다루지 않은 실용적·구체적 의문점

답변은 두괄식 구조 (결론 먼저 → 상세 설명)

자연스러운 어투: "~라고 합니다"보다 "~더라고요", "~네요" 선호

실제 경험이나 출처 언급: "제가 직접 해봤을 때", "주변 지인 경험상"

친근한 톤 유지: "이것만 기억하세요", "여기 꼭 확인하셔야 돼요"

📍 5. 마무리 + 콜투액션

<p style="line-height: 2.0; font-size: 17px;">

(마무리 멘트: 독자에게 전하고 싶은 핵심 메시지 2~3줄)<br><br>

(자연스러운 대화체로 격려 또는 응원: "여러분도 꼭 해보세요", "제 경험이 도움 되셨으면 좋겠네요")<br><br>

(행동 유도 문장: "오늘부터 ○○ 해보세요", "이 방법으로 ○○ 하시길 바랍니다" 등)<br><br>

(따뜻하고 공감 가는 톤으로 마무리, 친구에게 조언하듯)

</p>

<br>

작성 가이드:

독자의 행동 변화를 유도하는 긍정적 메시지

메인 키워드 자연스럽게 1회 포함

과도한 광고성 문구 지양 (네이버 정책 위배 가능)

제목에서 제시한 문제의 해결책을 다시 한번 상기시킴

친근하고 따뜻한 어투: "함께 해봐요", "응원할게요", "도움 되셨길 바라요"

"~입니다" 남발 금지: "~네요", "~예요", "~거예요" 등으로 자연스럽게

📍 6. 해시태그 (7~10개)

<p style="line-height: 1.8; color: #0066cc;">

#메인키워드 #연관키워드1 #연관키워드2 #연관키워드3 #연관키워드4 #연관키워드5 #연관키워드6 #연관키워드7 #연관키워드8 #연관키워드9

</p>

작성 가이드:

첫 번째는 무조건 메인 키워드

나머지는 롱테일 키워드, 유사 검색어, 관련 주제 키워드

각 해시태그 앞에 반드시 # 기호 포함

띄어쓰기 없이 붙여서 작성 (예: #국민연금수령나이)

제목과 본문에 등장한 주요 키워드 활용

🎨 랜덤 컬러 사용 규칙

각 테이블 및 박스의 background-color에는 매번 다른 랜덤 hex code 사용

사용 가능 색상 예시:#FFF9E3 (연한 노랑)

#E8F5E9 (연한 초록)

#E3F2FD (연한 파랑)

#FCE4EC (연한 핑크)

#F3E5F5 (연한 보라)

#FFF3E0 (연한 주황)

#F1F8E9 (연한 라임)

#FFEBEE (연한 빨강)

#E0F2F1 (연한 민트)

본문 가독성을 해치지 않는 연한 파스텔 톤 계열 사용

✅ 최종 체크리스트

작성 완료 후 아래 항목을 반드시 확인하세요.

[ ] 최적화 제목이 키워드 유형에 맞는 공식으로 생성되었는가?

[ ] 제목에 클릭 유도 요소와 구체적 수치가 포함되었는가?

[ ] 메인 키워드가 제목, 인트로, 본문, 마무리에 자연스럽게 분산 배치되었는가?

[ ] 모든 문단이 2~3줄마다 줄바꿈 되어 모바일 가독성이 확보되었는가?

[ ] 각 섹션에 구체적 수치, 지역, 실제 경험 등이 1개 이상 포함되었는가?

[ ] 소제목에 순번(1, 2, 3...)이 없고, 궁금증 유발형으로 작성되었는가?

[ ] 강조 박스에 각 섹션의 핵심 메시지가 명확하게 담겼는가?

[ ] Q&A 질문이 본문과 중복되지 않고, 실용적·구체적인가?

[ ] 해시태그가 7~10개이며, # 기호가 모두 포함되었는가?

[ ] 전체 HTML 코드가 하나의 블록으로 깔끔하게 출력되었는가?

🚀 사용 예시

예시 1: 해결 중심 키워드

입력: "에어컨 청소"

STEP 1 제목 생성: "성남 에어컨 청소 업체 3곳 비교해보니 가격보다 중요한 게 있었다"

출력: (위 구조를 따라 완성된 HTML 코드 블록 1개)

예시 2: 신뢰도 중심 키워드

입력: "건강보험 피부양자 자격"

STEP 1 제목 생성: "건강보험 피부양자 자격 몰랐다가 200만원 추가 납부한 실제 사례 (2025)"

출력: (위 구조를 따라 완성된 HTML 코드 블록 1개)

예시 3: 정보 탐색 키워드

입력: "다이어트 식단"

STEP 1 제목 생성: "다이어트 식단 3개월 따라했는데 실패한 이유, 이렇게 바꿨더니 성공"

출력: (위 구조를 따라 완성된 HTML 코드 블록 1개)

예시 4: 비교/선택 키워드

입력: "전기차 보험"

STEP 1 제목 생성: "전기차 보험 5개 상품 가입해보니 숨겨진 함정 조항 있었다"

출력: (위 구조를 따라 완성된 HTML 코드 블록 1개)

💡 출력 형식 - 매우 중요!

**절대 지켜야 할 출력 규칙:**

1. 분석, 설명, 체크리스트 등 어떠한 부가 설명도 출력하지 마세요.
2. 메타 정보(분석, 제목 등)도 출력하지 마세요.
3. 마크다운 코드 블록 표시(백틱 3개)도 사용하지 마세요.
4. 오직 <!DOCTYPE html>부터 시작하는 완전한 HTML 문서만 출력하세요.
5. HTML 문서는 </html>로 끝나야 하며, 그 이후에는 아무것도 출력하지 마세요.
6. 해시태그 이후에 체크리스트나 추가 정보를 절대 출력하지 마세요.

**올바른 출력 예시:**

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    ...
</head>
<body>
    ...
    <p style="line-height: 1.8; color: #0066cc;">
    #메인키워드 #연관키워드1 #연관키워드2
    </p>
</body>
</html>

(여기서 끝! 이후에는 아무것도 출력 금지)

이제 위 규칙에 따라 제공된 뉴스 기사를 바탕으로 순수한 HTML 문서만 생성하세요.`;

        // 디버그 로그 함수
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('ko-KR');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.className = `log-${type}`;
            messageSpan.textContent = message;
            
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(messageSpan);
            debugLog.appendChild(logEntry);
            
            // 자동 스크롤
            debugLog.scrollTop = debugLog.scrollHeight;
            
            // 콘솔에도 출력
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // 로그 지우기
        function clearLog() {
            debugLog.innerHTML = '';
            log('로그가 초기화되었습니다.', 'info');
        }

        // 상태 메시지 표시
        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status show ${type}`;
        }

        // 상태 메시지 숨기기
        function hideStatus() {
            statusDiv.className = 'status';
        }

        // 통계 업데이트
        function updateStats() {
            const selectedCount = newsData.filter(item => item.selected).length;
            totalCountSpan.textContent = newsData.length;
            selectedCountSpan.textContent = selectedCount;
            
            // 선택된 뉴스가 있으면 AI 원고 생성 버튼 활성화
            generateBtn.disabled = selectedCount === 0;
        }
        
        // API 키 저장 (config.json)
        function saveConfig() {
            const apiKey = apiKeyInput.value.trim();
            
            if (!apiKey) {
                showStatus('⚠️ API 키를 입력해주세요!', 'error');
                return;
            }
            
            const config = {
                gemini_api_key: apiKey,
                saved_at: new Date().toISOString()
            };
            
            // JSON 파일 생성 및 다운로드
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // localStorage에도 저장
            localStorage.setItem('gemini_api_key', apiKey);
            
            log('✅ API 키가 config.json 파일로 저장되었습니다', 'success');
            showStatus('✅ config.json 파일이 다운로드되었습니다!', 'success');
            setTimeout(() => hideStatus(), 3000);
        }
        
        // API 키 불러오기 (config.json)
        function loadConfig() {
            configFileInput.click();
        }
        
        // 파일 선택 시 자동 로드
        configFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const config = JSON.parse(text);
                
                if (config.gemini_api_key) {
                    apiKeyInput.value = config.gemini_api_key;
                    localStorage.setItem('gemini_api_key', config.gemini_api_key);
                    
                    log('✅ config.json 파일에서 API 키를 불러왔습니다', 'success');
                    showStatus('✅ API 키가 자동으로 입력되었습니다!', 'success');
                    setTimeout(() => hideStatus(), 3000);
                } else {
                    throw new Error('API 키를 찾을 수 없습니다.');
                }
            } catch (error) {
                log(`❌ 설정 파일 로드 실패: ${error.message}`, 'error');
                showStatus('⚠️ 올바른 config.json 파일이 아닙니다!', 'error');
            }
            
            // 파일 입력 초기화
            configFileInput.value = '';
        });
        
        // 페이지 로드 시 localStorage에서 API 키 & 저장 경로 자동 로드
        function autoLoadApiKey() {
            const savedApiKey = localStorage.getItem('gemini_api_key');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
                log('✅ 저장된 API 키를 자동으로 불러왔습니다', 'success');
            }
            
            // 폴더는 File System Access API로 선택하므로 경로 저장 불필요
        }
        
        // 폴더 선택 (silver.html 방식 적용)
        async function chooseFolder() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    log('⚠️ 이 브라우저는 폴더 선택을 지원하지 않습니다', 'warning');
                    log('💡 Chrome 또는 Edge 브라우저를 사용해주세요', 'info');
                    showStatus('⚠️ Chrome/Edge 브라우저를 사용해주세요', 'warning');
                    setTimeout(() => hideStatus(), 5000);
                    return;
                }
                
                selectedDirectoryHandle = await window.showDirectoryPicker();
                folderPathLabel.innerText = `✅ 선택됨: ${selectedDirectoryHandle.name}`;
                folderPathLabel.style.color = '#2e7d32';
                log(`✅ 폴더 선택됨: ${selectedDirectoryHandle.name}`, 'success');
                log('📁 폴더 핸들이 저장되었습니다. 이미지와 원고는 이 폴더에 저장됩니다.', 'success');
                showStatus(`✅ 폴더 선택 완료: ${selectedDirectoryHandle.name}`, 'success');
                setTimeout(() => hideStatus(), 3000);
            } catch (e) {
                if (e.name === 'AbortError') {
                    log('⚠️ 폴더 선택이 취소되었습니다', 'warning');
                    showStatus('폴더 선택이 취소되었습니다', 'warning');
                } else {
                    log(`❌ 폴더 선택 오류: ${e.message}`, 'error');
                    showStatus(`⚠️ 오류: ${e.message}`, 'error');
                }
                setTimeout(() => hideStatus(), 3000);
            }
        }
        
        // 폴더 권한 확인 (silver.html 방식)
        async function verifyPermission(handle) {
            const options = { mode: 'readwrite' };
            if ((await handle.queryPermission(options)) === 'granted') return true;
            if ((await handle.requestPermission(options)) === 'granted') return true;
            return false;
        }
        
        // saveFolderPath는 더 이상 사용하지 않음 (folderPathLabel로 대체됨)
        
        // AI 원고 생성 섹션 열기
        function openAiSection() {
            const selectedNews = newsData.filter(item => item.selected);
            
            if (selectedNews.length === 0) {
                showStatus('⚠️ 뉴스를 선택해주세요!', 'error');
                return;
            }
            
            log(`AI 원고 생성 모드 시작 (선택된 뉴스: ${selectedNews.length}개)`, 'info');
            log(`사용할 프롬프트: 하드코딩된 전문 프롬프트 (${HARDCODED_PROMPT.length}자)`, 'debug');
            aiSection.style.display = 'block';
            aiSection.scrollIntoView({ behavior: 'smooth' });
        }
        
        // AI 원고 생성 섹션 닫기
        function closeAiSection() {
            aiSection.style.display = 'none';
            parsedContentPreview.style.display = 'none';
            aiPreview.style.display = 'none';
            log('AI 원고 생성 모드 종료', 'info');
        }
        
        // 원고 생성 (하드코딩된 프롬프트 사용) - 각 뉴스마다 개별 원고 생성
        async function generateArticle() {
            const selectedNews = newsData.filter(item => item.selected);
            const apiKey = apiKeyInput.value.trim();
            
            if (!apiKey) {
                showStatus('⚠️ Gemini API 키를 입력해주세요!', 'error');
                apiKeyInput.focus();
                return;
            }
            
            // 저장 폴더 확인 (silver.html 방식)
            if (!selectedDirectoryHandle) {
                log('⚠️ 폴더가 선택되지 않았습니다', 'warning');
                showStatus('⚠️ 폴더를 먼저 선택해주세요!', 'error');
                generateArticleBtn.disabled = false;
                return;
            }
            
            // 권한 확인
            if (!(await verifyPermission(selectedDirectoryHandle))) {
                log('⚠️ 폴더 권한이 필요합니다', 'error');
                showStatus('⚠️ 폴더 권한이 필요합니다. 폴더를 다시 선택해주세요.', 'error');
                generateArticleBtn.disabled = false;
                return;
            }
            
            log(`📁 선택한 폴더 사용: ${selectedDirectoryHandle.name}`, 'success');
            log('💡 이미지와 원고가 선택한 폴더에 저장됩니다', 'info');
            
            log('=== AI 원고 생성 시작 ===', 'info');
            log(`선택된 뉴스: ${selectedNews.length}개`, 'info');
            log(`각 뉴스마다 개별 원고를 생성합니다`, 'info');
            log('하드코딩된 프롬프트 사용 (100% 원본 유지)', 'info');
            showStatus(`${selectedNews.length}개의 원고를 생성하는 중...`, 'loading');
            generateArticleBtn.disabled = true;
            
            const successCount = [];
            const failedCount = [];
            
            try {
                // 각 뉴스에 대해 순차적으로 원고 생성
                for (let i = 0; i < selectedNews.length; i++) {
                    const news = selectedNews[i];
                    const newsIndex = i + 1;
                    
                    log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`, 'info');
                    log(`📰 [${newsIndex}/${selectedNews.length}] 원고 생성 중...`, 'info');
                    log(`제목: ${news.title}`, 'info');
                    log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`, 'info');
                    showStatus(`[${newsIndex}/${selectedNews.length}] "${news.title.substring(0, 30)}..." 원고 생성 중...`, 'loading');
                    
                    try {
                        // 1단계: 해당 뉴스의 본문 가져오기
                        log(`📄 본문 크롤링 중...`, 'info');
                        
                        // CORS 프록시를 사용하여 뉴스 본문 가져오기
                        const corsProxies = [
                            '',
                            'https://api.allorigins.win/raw?url=',
                            'https://corsproxy.io/?',
                            'https://api.codetabs.com/v1/proxy?quest='
                        ];
                        
                        let content = null;
                        let articleBody = null;
                        
                        for (const proxy of corsProxies) {
                            try {
                                const proxyUrl = proxy + encodeURIComponent(news.link);
                                const fetchResponse = await fetch(proxyUrl, {
                                    method: 'GET',
                                    headers: {
                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                                    }
                                });
                                
                                if (fetchResponse.ok) {
                                    // ArrayBuffer로 받아서 EUC-KR 인코딩 처리
                                    const arrayBuffer = await fetchResponse.arrayBuffer();
                                    let html = '';
                                    
                                    // EUC-KR 디코딩 시도
                                    try {
                                        const decoder = new TextDecoder('euc-kr');
                                        html = decoder.decode(arrayBuffer);
                                        log(`  ✓ EUC-KR 디코딩 성공`, 'debug');
                                    } catch (e) {
                                        // UTF-8로 시도
                                        try {
                                            const decoder = new TextDecoder('utf-8');
                                            html = decoder.decode(arrayBuffer);
                                            log(`  ⚠ UTF-8 디코딩 사용 (인코딩 문제 가능)`, 'warning');
                                        } catch (e2) {
                                            // 최후의 수단
                                            const decoder = new TextDecoder('iso-8859-1');
                                            html = decoder.decode(arrayBuffer);
                                            log(`  ⚠ Latin1 디코딩 사용 (인코딩 문제 가능)`, 'warning');
                                        }
                                    }
                                    
                                    const parser = new DOMParser();
                                    const doc = parser.parseFromString(html, 'text/html');
                                    
                                    // 본문 찾기 (더 많은 선택자 시도)
                                    const selectors = [
                                        'div.content_view',
                                        'div#content_view',
                                        'div.articleBody',
                                        'div#articleBody',
                                        'div.news_bodytext',
                                        'div.article_body',
                                        'div.view_body',
                                        'div.articleView',
                                        'article.article',
                                        'div.article-content',
                                        'div.news-content',
                                        'div.article',
                                        'div#article',
                                        'div.contents',
                                        'div#contents',
                                        'div.text',
                                        'div#text',
                                        'div[class*="content"]',
                                        'div[class*="article"]',
                                        'div[class*="body"]'
                                    ];
                                    
                                    for (const selector of selectors) {
                                        try {
                                            articleBody = doc.querySelector(selector);
                                            if (articleBody) {
                                                const text = articleBody.textContent.trim();
                                                // 한글이 포함되어 있고 충분한 길이인지 확인
                                                if (text.length > 100 && /[가-힣]/.test(text)) {
                                                    log(`  ✓ 본문 발견: ${selector} (${text.length}자)`, 'debug');
                                                    break;
                                                }
                                            }
                                        } catch (e) {
                                            continue;
                                        }
                                    }
                                    
                                    // 모든 선택자 실패 시, 가장 긴 텍스트를 가진 div 찾기
                                    if (!articleBody || !/[가-힣]/.test(articleBody.textContent)) {
                                        log(`  ⚠ 모든 선택자 실패, 가장 긴 텍스트 div 찾기...`, 'warning');
                                        const allDivs = doc.querySelectorAll('div');
                                        let maxLength = 0;
                                        let longestDiv = null;
                                        
                                        allDivs.forEach(div => {
                                            const text = div.textContent.trim();
                                            if (text.length > maxLength && /[가-힣]/.test(text) && text.length > 200) {
                                                maxLength = text.length;
                                                longestDiv = div;
                                            }
                                        });
                                        
                                        if (longestDiv) {
                                            articleBody = longestDiv;
                                            log(`  ✓ 가장 긴 본문 div 발견: ${maxLength}자`, 'debug');
                                        }
                                    }
                                    
                                    if (articleBody) {
                                        // 이미지 URL 추출 (onclick="GoImg('...')" 또는 src에서)
                                        const imageUrls = [];
                                        const imgTags = articleBody.querySelectorAll('img');
                                        
                                        imgTags.forEach(img => {
                                            let imgUrl = null;
                                            
                                            // onclick="GoImg('URL')" 형태에서 추출
                                            const onclick = img.getAttribute('onclick');
                                            if (onclick) {
                                                const goImgMatch = onclick.match(/GoImg\(['"]([^'"]+)['"]\)/);
                                                if (goImgMatch) {
                                                    imgUrl = goImgMatch[1];
                                                }
                                            }
                                            
                                            // onclick이 없거나 실패하면 src에서 추출
                                            if (!imgUrl) {
                                                imgUrl = img.getAttribute('src');
                                            }
                                            
                                            if (imgUrl) {
                                                // 상대 경로를 절대 경로로 변환
                                                if (imgUrl.startsWith('//')) {
                                                    imgUrl = 'https:' + imgUrl;
                                                } else if (imgUrl.startsWith('/')) {
                                                    imgUrl = 'https://news.nate.com' + imgUrl;
                                                } else if (!imgUrl.startsWith('http')) {
                                                    imgUrl = 'https://news.nate.com/' + imgUrl;
                                                }
                                                
                                                // 썸네일 URL이 아닌 원본 URL 추출 시도
                                                // thumbnews.nateimg.co.kr은 썸네일이므로 제외
                                                if (!imgUrl.includes('thumbnews.nateimg.co.kr')) {
                                                    imageUrls.push(imgUrl);
                                                } else {
                                                    // 썸네일에서 원본 URL 추출 시도
                                                    const orgMatch = imgUrl.match(/\/\/news\.nateimg\.co\.kr\/orgImg\/[^'"]+/);
                                                    if (orgMatch) {
                                                        imageUrls.push('https:' + orgMatch[0]);
                                                    }
                                                }
                                            }
                                        });
                                        
                                        log(`  📷 이미지 발견: ${imageUrls.length}개`, imageUrls.length > 0 ? 'success' : 'info');
                                        
                                        // 불필요한 태그 제거
                                        const scripts = articleBody.querySelectorAll('script, style, iframe, noscript, header, footer, nav, aside, button, form');
                                        scripts.forEach(el => el.remove());
                                        
                                        // 텍스트 추출 (innerHTML에서 직접 추출하여 인코딩 보존)
                                        let fullText = '';
                                        
                                        // innerHTML에서 직접 텍스트 추출 시도
                                        const tempDiv = document.createElement('div');
                                        tempDiv.innerHTML = articleBody.innerHTML;
                                        
                                        // 모든 텍스트 노드 수집
                                        const textNodes = [];
                                        const walker = document.createTreeWalker(
                                            tempDiv,
                                            NodeFilter.SHOW_TEXT,
                                            null,
                                            false
                                        );
                                        
                                        let node;
                                        while (node = walker.nextNode()) {
                                            const text = node.textContent.trim();
                                            if (text.length > 0) {
                                                textNodes.push(text);
                                            }
                                        }
                                        
                                        fullText = textNodes.join(' ');
                                        
                                        // 한글, 숫자, 기본 문장부호 포함
                                        const koreanPattern = /[가-힣0-9\s,.!?()\"\'%~-]+/g;
                                        const koreanTexts = fullText.match(koreanPattern) || [];
                                        let koreanOnly = koreanTexts.join(' ').replace(/\s+/g, ' ').trim();
                                        
                                        // 인코딩 문제로 깨진 문자 제거 (숫자만 있는 줄, 특수문자만 있는 줄)
                                        const lines = koreanOnly.split(/\s+/);
                                        const validLines = lines.filter(line => {
                                            // 한글이 포함되어 있거나, 의미있는 숫자/문장이 있는 경우만
                                            return /[가-힣]/.test(line) || 
                                                   (line.length > 3 && /[0-9가-힣]/.test(line));
                                        });
                                        koreanOnly = validLines.join(' ').trim();
                                        
                                        if (koreanOnly.length > 100) {
                                            content = {
                                                link: news.link,
                                                content: koreanOnly.substring(0, 15000),
                                                korean_length: koreanOnly.length,
                                                images: imageUrls // 이미지 URL 목록 추가
                                            };
                                            log(`✓ 본문 추출 성공: ${koreanOnly.length.toLocaleString()}자`, 'success');
                                            break;
                                        }
                                    }
                                }
                            } catch (err) {
                                continue;
                            }
                        }
                        
                        if (!content || content.korean_length < 100) {
                            throw new Error(`본문을 가져올 수 없습니다 (${content ? content.korean_length : 0}자)`);
                        }
                            
                            // 파싱된 내용 표시
                            parsedContent.textContent = `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`;
                            parsedContent.textContent += `제목: ${news.title}\n`;
                        parsedContent.textContent += `파싱된 내용 (${content.korean_length.toLocaleString()}자):\n`;
                        parsedContent.textContent += `이미지: ${content.images ? content.images.length : 0}개\n`;
                            parsedContent.textContent += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n`;
                            parsedContent.textContent += content.content;
                            parsedContentPreview.style.display = 'block';
                            parsedContentPreview.scrollIntoView({ behavior: 'smooth' });
                        
                        // 1단계: 이미지 다운로드 (원고 생성 전)
                        const images = content.images || [];
                        let downloadedImages = [];
                        
                        // 각 뉴스마다 폴더 생성 (제목_날짜 형식)
                        const now = new Date();
                        const dateStr = now.getFullYear().toString() + 
                                       String(now.getMonth() + 1).padStart(2, '0') + 
                                       String(now.getDate()).padStart(2, '0') + '_' +
                                       String(now.getHours()).padStart(2, '0') +
                                       String(now.getMinutes()).padStart(2, '0') +
                                       String(now.getSeconds()).padStart(2, '0');
                        const safeTitle = news.title.replace(/[<>:"/\\|?*\']/g, '').substring(0, 50).replace(/\s/g, '_');
                        const folderName = `${safeTitle}_${dateStr}`;
                        
                        // 선택한 폴더 안에 새 폴더 생성
                        let newsFolderHandle = null;
                        if (selectedDirectoryHandle) {
                            try {
                                newsFolderHandle = await selectedDirectoryHandle.getDirectoryHandle(folderName, { create: true });
                                log(`📁 폴더 생성 완료: ${folderName}`, 'success');
                            } catch (e) {
                                log(`⚠️ 폴더 생성 실패: ${e.message}`, 'warning');
                            }
                        }
                        
                        if (images.length > 0) {
                            log(`📷 이미지 다운로드 시작: ${images.length}개`, 'info');
                            showStatus(`📷 이미지 다운로드 중... (${images.length}개)`, 'loading');
                            
                            // 각 이미지 다운로드 (생성한 폴더에 저장)
                            for (let imgIdx = 0; imgIdx < images.length; imgIdx++) {
                                const imgUrl = images[imgIdx];
                                try {
                                    log(`  📥 이미지 ${imgIdx + 1}/${images.length} 다운로드 중...`, 'info');
                                    
                                    // CORS 프록시를 통해 이미지 가져오기
                                    const corsProxies = [
                                        '',
                                        'https://api.allorigins.win/raw?url=',
                                        'https://corsproxy.io/?',
                                        'https://api.codetabs.com/v1/proxy?quest='
                                    ];
                                    
                                    let imgBlob = null;
                                    for (const proxy of corsProxies) {
                                        try {
                                            const proxyUrl = proxy + encodeURIComponent(imgUrl);
                                            const imgResponse = await fetch(proxyUrl, {
                                                headers: {
                                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                                                    'Referer': 'https://news.nate.com/'
                                                }
                                            });
                                            
                                            if (imgResponse.ok) {
                                                imgBlob = await imgResponse.blob();
                                                break;
                                            }
                                        } catch (e) {
                                            continue;
                                        }
                                    }
                                    
                                    if (imgBlob) {
                                        // 파일명 생성
                                        const urlParts = imgUrl.split('/');
                                        const fileName = urlParts[urlParts.length - 1].split('?')[0] || `image_${imgIdx + 1}.jpg`;
                                        
                                        // File System Access API로 생성한 폴더에 저장
                                        if (newsFolderHandle) {
                                            try {
                                                const fileHandle = await newsFolderHandle.getFileHandle(fileName, { create: true });
                                                const writable = await fileHandle.createWritable();
                                                await writable.write(imgBlob);
                                                await writable.close();
                                                downloadedImages.push(fileName);
                                                log(`  ✅ 이미지 저장 완료: ${fileName} (${folderName} 폴더)`, 'success');
                                            } catch (e) {
                                                // File System Access API 실패 시 기본 다운로드
                                                log(`  ⚠️ 폴더 저장 실패, 기본 다운로드 사용: ${e.message}`, 'warning');
                                                const url = URL.createObjectURL(imgBlob);
                                                const a = document.createElement('a');
                                                a.href = url;
                                                a.download = fileName;
                                                document.body.appendChild(a);
                                                a.click();
                                                document.body.removeChild(a);
                                                URL.revokeObjectURL(url);
                                                downloadedImages.push(fileName);
                                                log(`  ✅ 이미지 다운로드 완료: ${fileName}`, 'success');
                                            }
                                        } else {
                                            // 폴더가 생성되지 않았으면 기본 다운로드
                                            const url = URL.createObjectURL(imgBlob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = fileName;
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                            URL.revokeObjectURL(url);
                                            downloadedImages.push(fileName);
                                            log(`  ✅ 이미지 다운로드 완료: ${fileName} (기본 다운로드 폴더)`, 'success');
                                        }
                                    } else {
                                        log(`  ⚠️ 이미지 다운로드 실패: ${imgUrl}`, 'warning');
                                    }
                                } catch (error) {
                                    log(`  ❌ 이미지 다운로드 오류: ${error.message}`, 'error');
                                }
                            }
                            
                            log(`📷 이미지 다운로드 완료: ${downloadedImages.length}/${images.length}개`, downloadedImages.length === images.length ? 'success' : 'warning');
                            
                            if (downloadedImages.length > 0) {
                                if (targetDirectory) {
                                    showStatus(`✅ 이미지 저장 완료: ${downloadedImages.length}개 (선택한 폴더)`, 'success');
                                } else {
                                    showStatus(`✅ 이미지 다운로드 완료: ${downloadedImages.length}개 (기본 다운로드 폴더)`, 'success');
                                }
                                setTimeout(() => hideStatus(), 3000);
                            }
                        } else {
                            log(`📷 이미지 없음`, 'info');
                        }
                        
                        // 2단계: Gemini API로 원고 생성 (브라우저에서 직접 호출)
                        log(`🤖 Gemini AI로 원고 생성 중...`, 'info');
                        
                        const fullPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📰 제공된 뉴스 기사 원문
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

${content.content}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 작성 지침
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

${HARDCODED_PROMPT}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 중요: 반드시 지켜야 할 사항
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 위에 제공된 뉴스 기사 원문의 내용을 반드시 사용하여 작성하세요.
2. 뉴스 기사에 나온 선수명, 팀명, 점수, 기록 등을 정확히 인용하세요.
3. 뉴스 기사에 없는 내용을 임의로 만들지 마세요.
4. 뉴스 기사의 핵심 내용을 모두 포함하여 작성하세요.
5. 순수한 HTML 문서만 출력하세요 (<!DOCTYPE html>로 시작, </html>로 끝)
6. 분석, 설명, 체크리스트 등 부가 설명은 출력하지 마세요.

지금 제공된 뉴스 기사를 바탕으로 블로그 원고를 작성하세요.
`;
                        
                        // Gemini API 직접 호출
                        const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
                        
                        const geminiResponse = await fetch(geminiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [{
                                        text: fullPrompt
                                    }]
                                }]
                            })
                        });
                        
                        if (!geminiResponse.ok) {
                            const errorData = await geminiResponse.json();
                            throw new Error(errorData.error?.message || 'AI 원고 생성 실패');
                        }
                        
                        const geminiData = await geminiResponse.json();
                        let generatedText = geminiData.candidates[0].content.parts[0].text;
                        
                        // HTML 추출
                        let cleanHtml = generatedText;
                        const htmlMatch = generatedText.match(/```html\s*\n([\s\S]*?)\n```/i);
                        if (htmlMatch) {
                            cleanHtml = htmlMatch[1].trim();
                        } else {
                            const htmlDocMatch = generatedText.match(/(<!DOCTYPE html>[\s\S]*?<\/html>)/i);
                            if (htmlDocMatch) {
                                cleanHtml = htmlDocMatch[1].trim();
                            }
                        }
                        
                        // 파일명 생성 (이미지 다운로드 부분에서 생성한 변수 재사용)
                        const fileName = `${safeTitle}_${dateStr}.html`;
                        
                        // File System Access API로 생성한 폴더에 저장 (silver.html 방식)
                        if (newsFolderHandle) {
                            try {
                                // 권한 확인
                                if (!(await verifyPermission(newsFolderHandle))) {
                                    throw new Error('폴더 권한이 필요합니다');
                                }
                                
                                // 파일 저장
                                const fileHandle = await newsFolderHandle.getFileHandle(fileName, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(cleanHtml);
                                await writable.close();
                                
                                log(`✅ [${newsIndex}/${selectedNews.length}] 원고 생성 및 저장 완료!`, 'success');
                                log(`📄 파일: ${fileName}`, 'success');
                                log(`📁 저장 위치: ${selectedDirectoryHandle.name}\\${folderName} 폴더`, 'success');
                                
                                successCount.push({
                                    title: news.title,
                                    path: `${selectedDirectoryHandle.name}\\${folderName}\\${fileName}`
                                });
                            } catch (error) {
                                log(`⚠️ 폴더 저장 실패, 기본 다운로드 사용: ${error.message}`, 'warning');
                                // 폴더 저장 실패 시 기본 다운로드
                                const blob = new Blob([cleanHtml], { type: 'text/html;charset=utf-8' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = fileName;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                                
                                log(`✅ [${newsIndex}/${selectedNews.length}] 원고 생성 및 다운로드 완료!`, 'success');
                                log(`📄 파일: ${fileName} (기본 다운로드 폴더)`, 'success');
                                
                                successCount.push({
                                    title: news.title,
                                    path: fileName
                                });
                            }
                        } else {
                            // 폴더가 선택되지 않은 경우 기본 다운로드
                            const blob = new Blob([cleanHtml], { type: 'text/html;charset=utf-8' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileName;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            log(`✅ [${newsIndex}/${selectedNews.length}] 원고 생성 및 다운로드 완료!`, 'success');
                            log(`📄 파일: ${fileName}`, 'success');
                            log(`📁 브라우저 기본 다운로드 폴더에 저장되었습니다`, 'info');
                            
                            successCount.push({
                                title: news.title,
                                path: fileName
                            });
                        }
                        
                    } catch (error) {
                        log(`❌ [${newsIndex}/${selectedNews.length}] 실패: ${error.message}`, 'error');
                        failedCount.push({
                            title: news.title,
                            error: error.message
                        });
                    }
                    
                    // 다음 뉴스 처리 전 짧은 대기 (API 제한 방지)
                    if (i < selectedNews.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                // 최종 결과 출력
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                log('🎉 모든 원고 생성 작업 완료!', 'success');
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                log(`✅ 성공: ${successCount.length}개`, 'success');
                log(`❌ 실패: ${failedCount.length}개`, failedCount.length > 0 ? 'error' : 'info');
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                
                if (successCount.length > 0) {
                    log('📁 생성된 원고 목록:', 'success');
                    successCount.forEach((item, idx) => {
                        log(`  ${idx + 1}. ${item.title.substring(0, 40)}...`, 'success');
                        log(`     → ${item.path}`, 'debug');
                    });
                }
                
                if (failedCount.length > 0) {
                    log('', 'info');
                    log('❌ 실패한 원고 목록:', 'error');
                    failedCount.forEach((item, idx) => {
                        log(`  ${idx + 1}. ${item.title.substring(0, 40)}...`, 'error');
                        log(`     → 원인: ${item.error}`, 'warning');
                    });
                }
                
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                log('=== AI 원고 생성 완료 ===', 'success');
                
                // 미리보기는 마지막 성공한 원고 표시
                if (successCount.length > 0) {
                    const locationText = selectedDirectoryHandle 
                        ? `선택한 폴더: ${selectedDirectoryHandle.name}`
                        : '브라우저 기본 다운로드 폴더';
                    previewContent.textContent = `총 ${successCount.length}개의 원고가 생성되었습니다.\n\n${locationText}`;
                    aiPreview.style.display = 'block';
                    aiPreview.scrollIntoView({ behavior: 'smooth' });
                }
                
                showStatus(`✅ 원고 생성 완료! (성공: ${successCount.length}, 실패: ${failedCount.length})`, 'success');
                setTimeout(() => hideStatus(), 5000);
                
            } catch (error) {
                log(`❌ 전체 프로세스 오류: ${error.message}`, 'error');
                showStatus(`⚠️ 오류 발생: ${error.message}`, 'error');
            } finally {
                generateArticleBtn.disabled = false;
            }
        }
        
        // HTML 파일 다운로드
        async function downloadArticle() {
            if (!generatedHTML) {
                showStatus('⚠️ 생성된 원고가 없습니다!', 'error');
                return;
            }
            
            // Blob 생성
            const blob = new Blob([generatedHTML], { type: 'text/html;charset=utf-8' });
            
            // File System Access API를 사용하여 선택한 폴더에 저장 시도
            if (selectedDirectoryHandle) {
                try {
                    const fileHandle = await selectedDirectoryHandle.getFileHandle(generatedFilename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    log(`✅ HTML 파일 저장 완료: ${generatedFilename}`, 'success');
                    log(`📁 저장 위치: ${selectedDirectoryHandle.name}`, 'info');
                    showStatus(`✅ 파일이 선택한 폴더에 저장되었습니다: ${generatedFilename}`, 'success');
                } catch (e) {
                    log(`⚠️ 폴더 저장 실패, 기본 다운로드 사용: ${e.message}`, 'warning');
                    // 기본 다운로드로 폴백
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = generatedFilename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showStatus(`✅ 파일이 다운로드되었습니다: ${generatedFilename}`, 'success');
                }
            } else {
                // 기본 다운로드
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = generatedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus(`✅ 파일이 다운로드되었습니다: ${generatedFilename}`, 'success');
            }
            
            setTimeout(() => hideStatus(), 5000);
        }

        // 스포츠 뉴스 크롤링 (브라우저에서 직접)
        async function collectNews() {
            log('=== 크롤링 시작 ===', 'info');
            showStatus('스포츠 뉴스를 수집하는 중입니다...', 'loading');
            collectBtn.disabled = true;

            try {
                // 오늘 날짜 생성
                const today = new Date();
                const dateStr = today.getFullYear().toString() + 
                               String(today.getMonth() + 1).padStart(2, '0') + 
                               String(today.getDate()).padStart(2, '0');
                
                // 스포츠 뉴스 URL
                const url = `https://news.nate.com/rank/interest?sc=spo&p=day&date=${dateStr}`;
                
                log(`📡 네이트 뉴스 크롤링 시도: ${url}`, 'info');
                
                // CORS 프록시 사용 (여러 옵션 시도)
                const corsProxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?',
                    'https://api.codetabs.com/v1/proxy?quest=',
                    'https://cors-anywhere.herokuapp.com/',
                    '' // 직접 시도 (마지막)
                ];
                
                let response = null;
                let html = null;
                let lastError = null;
                
                for (const proxy of corsProxies) {
                    try {
                        const proxyUrl = proxy ? (proxy + encodeURIComponent(url)) : url;
                        log(`🔄 프록시 시도: ${proxy || '직접 접근'}`, 'info');
                        
                        response = await fetch(proxyUrl, {
                            method: 'GET',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                                'Accept-Language': 'ko-KR,ko;q=0.9',
                                'Referer': 'https://news.nate.com/'
                            },
                            mode: 'cors'
                        });
                        
                        if (response.ok) {
                            // ArrayBuffer로 받아서 EUC-KR 인코딩 처리
                            const arrayBuffer = await response.arrayBuffer();
                            
                            // EUC-KR 디코딩 시도
                            try {
                                const decoder = new TextDecoder('euc-kr');
                                html = decoder.decode(arrayBuffer);
                                log(`✅ 프록시 성공: ${proxy || '직접 접근'} (EUC-KR 디코딩)`, 'success');
                            } catch (e) {
                                // UTF-8로 시도
                                try {
                                    const decoder = new TextDecoder('utf-8');
                                    html = decoder.decode(arrayBuffer);
                                    log(`✅ 프록시 성공: ${proxy || '직접 접근'} (UTF-8 디코딩)`, 'success');
                                } catch (e2) {
                                    // 최후의 수단
                                    const decoder = new TextDecoder('iso-8859-1');
                                    html = decoder.decode(arrayBuffer);
                                    log(`⚠️ 프록시 성공: ${proxy || '직접 접근'} (Latin1 디코딩, 인코딩 문제 가능)`, 'warning');
                                }
                            }
                            
                            if (html && html.length > 1000) {
                                log(`✅ HTML 수신 성공: ${html.length}자`, 'success');
                                break;
                            } else {
                                log(`⚠️ HTML이 너무 짧음: ${html ? html.length : 0}자`, 'warning');
                                html = null;
                            }
                        } else {
                            log(`⚠️ HTTP 오류: ${response.status} ${response.statusText}`, 'warning');
                            lastError = `HTTP ${response.status}`;
                        }
                    } catch (err) {
                        lastError = err.message;
                        log(`⚠️ 프록시 실패: ${proxy || '직접 접근'} - ${err.message}`, 'warning');
                        continue;
                    }
                }
                
                if (!html) {
                    throw new Error('모든 크롤링 방법이 실패했습니다. CORS 정책으로 인해 브라우저에서 직접 크롤링이 제한될 수 있습니다.');
                }
                
                // HTML 파싱 (인코딩은 이미 위에서 처리됨)
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // 제외할 키워드
                const excludeKeywords = [
                    '사진', 'mk포토', 'MK포토', '숏폼', '포토', '영상', '동영상', 
                    '갤러리', '화보', 'photo', 'PHOTO', 'shorts', 'SHORTS',
                    '웨이보', 'weibo', 'WEIBO', 'O! SPORTS', 'VIDEO', 'video'
                ];
                
                const newsList = [];
                
                // 1-5위 뉴스 추출
                const topNews = doc.querySelectorAll('.postRankSubjectList .mduSubjectList');
                topNews.forEach((item, index) => {
                    const titleEl = item.querySelector('h2.tit');
                    const linkEl = item.querySelector('a.lt1');
                    
                    if (titleEl) {
                        const rank = index + 1;
                        const title = titleEl.textContent.trim();
                        let link = linkEl ? linkEl.getAttribute('href') || '' : '';
                        
                        // 제외 키워드 체크
                        const titleLower = title.toLowerCase();
                        const shouldExclude = excludeKeywords.some(kw => titleLower.includes(kw.toLowerCase()));
                        if (shouldExclude) {
                            log(`  ⚠ 제외됨 (순위 ${rank}): ${title}`, 'warning');
                            return;
                        }
                        
                        // 상대 경로를 절대 경로로 변환
                        if (link.startsWith('//')) {
                            link = 'https:' + link;
                        } else if (link.startsWith('/')) {
                            link = 'https://news.nate.com' + link;
                        }
                        
                        newsList.push({ rank, title, link });
                    }
                });
                
                // 6-30위 뉴스 추출
                const otherNews = doc.querySelectorAll('#postRankSubject .mduSubject li');
                otherNews.forEach(item => {
                    const rankEl = item.querySelector('.mduRank dt em');
                    const titleEl = item.querySelector('h2');
                    const linkEl = item.querySelector('a');
                    
                    if (rankEl && titleEl) {
                        const rank = parseInt(rankEl.textContent.trim());
                        const title = titleEl.textContent.trim();
                        let link = linkEl ? linkEl.getAttribute('href') || '' : '';
                        
                        // 제외 키워드 체크
                        const titleLower = title.toLowerCase();
                        const shouldExclude = excludeKeywords.some(kw => titleLower.includes(kw.toLowerCase()));
                        if (shouldExclude) {
                            log(`  ⚠ 제외됨 (순위 ${rank}): ${title}`, 'warning');
                            return;
                        }
                        
                        // 상대 경로를 절대 경로로 변환
                        if (link.startsWith('//')) {
                            link = 'https:' + link;
                        } else if (link.startsWith('/')) {
                            link = 'https://news.nate.com' + link;
                        }
                        
                        newsList.push({ rank, title, link });
                    }
                });
                
                // 순위별로 정렬
                newsList.sort((a, b) => a.rank - b.rank);
                
                log(`✅ 데이터 수신 성공!`, 'success');
                log(`수집 날짜: ${dateStr}`, 'info');
                log(`뉴스 개수: ${newsList.length}개`, 'success');
                
                // 각 뉴스 로그
                newsList.slice(0, 5).forEach((item, index) => {
                        log(`[${item.rank}위] ${item.title.substring(0, 50)}...`, 'debug');
                });
                
                if (newsList.length > 5) {
                    log(`... 그 외 ${newsList.length - 5}개 뉴스`, 'debug');
                }
                
                // 뉴스 데이터 저장
                newsData = newsList.map((item, index) => ({
                    id: index + 1,
                    rank: item.rank,
                    title: item.title,
                    link: item.link,
                    selected: false
                }));
                
                renderNewsList();
                log(`✅ ${newsData.length}개의 뉴스를 성공적으로 표시했습니다!`, 'success');
                showStatus(`✅ ${newsData.length}개의 실시간 뉴스를 성공적으로 수집했습니다!`, 'success');
                setTimeout(hideStatus, 3000);

                selectAllBtn.disabled = false;
                resetBtn.disabled = false;
                statsDiv.style.display = 'flex';
                updateStats();

                log('=== 실시간 크롤링 완료 ===', 'success');

            } catch (error) {
                log(`❌ 크롤링 실패: ${error.message}`, 'error');
                console.error('Error:', error);
                
                // 상세한 에러 정보 표시
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'error');
                log('❌ 크롤링 실패 원인:', 'error');
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'error');
                
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    showStatus('⚠️ CORS 정책으로 인해 직접 크롤링이 제한됩니다.', 'error');
                    log('💡 해결 방법:', 'warning');
                    log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                    log('방법 1: 브라우저 확장 프로그램 사용', 'info');
                    log('   - Chrome 웹스토어에서 "CORS Unblock" 검색 후 설치', 'info');
                    log('   - 또는 "Allow CORS" 확장 프로그램 설치', 'info');
                    log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                    log('방법 2: 로컬 서버 실행', 'info');
                    log('   - 명령 프롬프트에서: python -m http.server 8000', 'info');
                    log('   - 브라우저에서: http://localhost:8000 접속', 'info');
                    log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
                } else {
                    showStatus(`⚠️ 크롤링 실패: ${error.message}`, 'error');
                    log(`상세 오류: ${error.message}`, 'error');
                }
                
            } finally {
                collectBtn.disabled = false;
            }
        }


        // 뉴스 목록 렌더링
        function renderNewsList() {
            newsList.innerHTML = '';
            
            newsData.forEach(item => {
                const newsItem = document.createElement('div');
                newsItem.className = `news-item ${item.selected ? 'selected' : ''}`;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `news-${item.id}`;
                checkbox.checked = item.selected;
                checkbox.addEventListener('change', (e) => {
                    item.selected = e.target.checked;
                    newsItem.classList.toggle('selected', item.selected);
                    updateStats();
                });

                const label = document.createElement('label');
                label.htmlFor = `news-${item.id}`;
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '10px';
                
                // 순위 표시
                if (item.rank) {
                    const rankSpan = document.createElement('span');
                    rankSpan.style.fontWeight = 'bold';
                    rankSpan.style.color = item.rank <= 5 ? '#667eea' : '#666';
                    rankSpan.style.minWidth = '50px';
                    rankSpan.textContent = `[${item.rank}위]`;
                    label.appendChild(rankSpan);
                }
                
                // 제목 (전체 표시, 줄바꿈 허용)
                const titleSpan = document.createElement('span');
                titleSpan.style.flex = '1';
                titleSpan.style.wordBreak = 'break-word';
                titleSpan.style.whiteSpace = 'normal';
                titleSpan.style.lineHeight = '1.6';
                titleSpan.textContent = item.title;
                label.appendChild(titleSpan);

                newsItem.appendChild(checkbox);
                newsItem.appendChild(label);
                newsList.appendChild(newsItem);
            });
        }

        // 전체 선택
        function selectAll() {
            log(`전체 선택: ${newsData.length}개 뉴스`, 'info');
            newsData.forEach(item => item.selected = true);
            renderNewsList();
            updateStats();
            showStatus('모든 뉴스가 선택되었습니다.', 'success');
            setTimeout(hideStatus, 2000);
        }

        // 초기화 (선택 해제만)
        function reset() {
            log('선택 초기화 실행', 'warning');
            
            // newsData 배열의 모든 선택 상태 해제
            newsData.forEach(item => {
                item.selected = false;
            });
            
            // 뉴스 목록 다시 렌더링 (체크박스 상태 업데이트)
            renderNewsList();
            
            // 통계 업데이트
            updateStats();
            
            showStatus('✅ 선택이 모두 해제되었습니다.', 'success');
            setTimeout(hideStatus, 2000);
        }

        // 이벤트 리스너
        collectBtn.addEventListener('click', collectNews);
        selectAllBtn.addEventListener('click', selectAll);
        resetBtn.addEventListener('click', reset);
        clearLogBtn.addEventListener('click', clearLog);
        
        // AI 관련 이벤트 리스너
        generateBtn.addEventListener('click', openAiSection);
        closeAiBtn.addEventListener('click', closeAiSection);
        generateArticleBtn.addEventListener('click', generateArticle);
        downloadBtn.addEventListener('click', downloadArticle);
        
        // API 키 관리 이벤트 리스너
        saveConfigBtn.addEventListener('click', saveConfig);
        loadConfigBtn.addEventListener('click', loadConfig);
        
        // 폴더 선택 이벤트 리스너
        chooseFolderBtn.addEventListener('click', chooseFolder);

        // 초기화 로그
        log('⚽ 채우미 - 스포츠 뉴스 크롤러', 'info');
        log('버전: 3.0 (완전 독립형 - 백엔드 불필요)', 'info');
        log('', 'info');
        
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
        log('🚀 브라우저에서 직접 크롤링을 시도합니다', 'info');
        log('💡 CORS 오류가 발생하면 브라우저 확장 프로그램을 사용하세요', 'info');
        log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
        
        // 페이지 로드 시 저장된 API 키 자동 로드
        autoLoadApiKey();
        
        // 페이지 로드 시 자동으로 크롤링 시작
        setTimeout(() => {
            log('', 'info');
            collectNews();
        }, 500);
        
        // 안내 메시지
        console.log('%c⚽ 채우미 - 스포츠 뉴스 크롤러', 'color: #667eea; font-size: 20px; font-weight: bold;');
        console.log('%c✅ 완전 독립형 - 백엔드 없이 작동합니다!', 'color: #38ef7d; font-size: 14px;');
        console.log('%c💡 CORS 오류 시 브라우저 확장 프로그램(CORS Unblock)을 사용하세요.', 'color: #764ba2;');
    </script>
</body>
</html>
